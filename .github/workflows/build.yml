name: Build and Release XianYuLauncher

on:
  push:
    # branches: [ "main" ] # 暂时屏蔽分支触发，仅通过 Tag 触发构建和发布，避免 Push 时重复运行
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  build:
    strategy:
      matrix:
        platform: [x86, x64, arm64]
    
    runs-on: windows-latest

    env:
      Solution_Name: XianYuLauncher.slnx
      Project_Path: XianYuLauncher/XianYuLauncher.csproj
      Configuration: Release
      Platform: ${{ matrix.platform }}
      # 用于签名的临时文件名
      Certificate_Path: GitHubActionsWorkflow.pfx

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # 1. 配置 MSBuild
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    # 1.5. 安装 .NET 10 (WinUI3 需要)
    - name: Install .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    # 2. 还原 secrets.json
    - name: Restore secrets.json
      shell: powershell
      run: |
        $secretJson = '${{ secrets.APP_SECRETS_JSON }}'
        if ([string]::IsNullOrWhiteSpace($secretJson)) {
            Write-Warning "APP_SECRETS_JSON is possibly empty or not set."
        }
        # 确保目录存在
        New-Item -ItemType Directory -Force -Path XianYuLauncher | Out-Null
        $secretJson | Out-File -FilePath XianYuLauncher/secrets.json -Encoding utf8
        Write-Host "secrets.json restored."

    # 3. 准备证书 (Base64 -> PFX)
    - name: Prepare Certificate
      shell: powershell
      run: |
        $pfxBase64 = '${{ secrets.PFX_BASE64 }}'
        if ([string]::IsNullOrWhiteSpace($pfxBase64)) {
            Write-Error "Secret PFX_BASE64 missing"
            exit 1
        }
        $pfxPath = "$env:GITHUB_WORKSPACE\sign.pfx"
        $pfxBytes = [System.Convert]::FromBase64String($pfxBase64)
        [System.IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
        
        Write-Host "Cert saved to $pfxPath"
        
        # 显式导入证书并获取 Thumbprint
        $password = ConvertTo-SecureString -String '${{ secrets.PFX_PASSWORD }}' -AsPlainText -Force
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $password
        
        echo "PFX_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
        Write-Host "Imported certificate with Thumbprint: $($cert.Thumbprint)"

    # 4. 根据 Tag 判断通道并修改 Manifest (Dev/Stable)
    - name: Configure Channel
      shell: powershell
      run: |
        $refName = "${{ github.ref_name }}"
        $manifestPath = "XianYuLauncher/Package.appxmanifest"
        [xml]$xml = Get-Content $manifestPath
        
        # 默认先把版本号提取出来 (去掉 v)
        $version = $refName
        if ($version.StartsWith("v")) { $version = $version.Substring(1) }
        # 提取基础版本号 (例如 1.4.0)
        if ($version -match '^(\d+\.\d+\.\d+)(.*)$') { 
            $baseVer = $matches[1]
            $suffix = $matches[2]
            
            # 默认 Revision 为 0
            $revision = 0
            
            # 尝试从后缀中提取数字作为 Revision
            # 例如: -dev1 -> 1, -beta05 -> 5
            if ($suffix -match '(\d+)$') {
                $revision = [int]$matches[1]
            }
            
            # 组合成 MSIX 需要的四段式 (Major.Minor.Build.Revision)
            $cleanVer = "$baseVer.$revision"
            
            $xml.Package.Identity.Version = $cleanVer
            Write-Host "Set Package Version: $cleanVer (Base: $baseVer, Rev: $revision)"
        }

        # 判断是否为 Dev/Beta 通道 (包含 -dev, -beta 或非 Tag 触发)
        # 这里逻辑：只要 Tag 里带 '-' (如 v1.4.0-dev)，或者干脆不是 v开头的 Tag，都算 Dev
        if ($refName -match '-' -or -not ($refName -match '^v\d')) {
            Write-Host "Channel: DEV/BETA"
            
            # 1. 修改包名 (Identity Name)
            $oldName = $xml.Package.Identity.Name
            $xml.Package.Identity.Name = "$oldName.Dev"
            Write-Host "Updated Identity Name: $oldName -> $($xml.Package.Identity.Name)"
            
            # 2. 修改显示名称 (DisplayName)
            # 注意: ms-resource: 是资源引用，不支持直接加后缀，需要直接改原始 manifest 里的字符串值
            # 如果原始值是 ms-resource:AppDisplayName，必须保留，但这里我们无法轻易修改 PRI 资源表
            # 临时方案: 直接硬编码显示名称，绕过资源引用 (仅用于 Dev)
            $xml.Package.Properties.DisplayName = "XianYu Launcher (Dev)"
            
            # 同时修改 VisualElements 里的名称
            if ($xml.Package.Applications.Application.VisualElements) {
                # 同理，硬编码名称
                $xml.Package.Applications.Application.VisualElements.DisplayName = "XianYu Launcher (Dev)"
            }
            
            # 3. 替换图标 (Assets/Dev 下的所有文件覆盖到 Assets)
            $devAssetsPath = "XianYuLauncher/Assets/Dev"
            $targetAssetsPath = "XianYuLauncher/Assets"
            
            if (Test-Path $devAssetsPath) {
                Get-ChildItem -Path $devAssetsPath -File | ForEach-Object {
                    $dest = Join-Path $targetAssetsPath $_.Name
                    Copy-Item $_.FullName $dest -Force
                    Write-Host "Replaced Asset: $($_.Name)"
                }
            } else {
                Write-Warning "Dev assets directory not found at $devAssetsPath"
            }
            
            # 4. 设置编译宏 (供 C# 代码使用)
            echo "Build_Constants=DEV_CHANNEL" >> $env:GITHUB_ENV
        } else {
            Write-Host "Channel: STABLE"
            # Stable 不需要改 Manifest，保持原样
            echo "Build_Constants=RELEASE_CHANNEL" >> $env:GITHUB_ENV
        }
        
        $xml.Save($manifestPath)

    # 5. 还原包
    - name: Restore
      run: nuget restore ${{ env.Solution_Name }}

    # 6. 构建并打包 (使用 MSBuild)
    - name: Build
      shell: powershell
      run: |
        msbuild ${{ env.Project_Path }} `
          /p:Configuration=${{ env.Configuration }} `
          /p:Platform=${{ env.Platform }} `
          /p:DefineConstants="${{ env.Build_Constants }}" `
          /p:GenerateAppxPackageOnBuild=true `
          /p:UapAppxPackageBuildMode=SideloadOnly `
          /p:AppxBundle=Never `
          /p:AppxPackageSigningEnabled=true `
          /p:PackageCertificateThumbprint="${{ env.PFX_THUMBPRINT }}" `
          /p:AppxPackageDir="$env:GITHUB_WORKSPACE\AppPackages\" `
          /p:PackageOutputPath="$env:GITHUB_WORKSPACE\AppPackages\" `
          /p:GenerateAppInstallerFile=false

    # === NEW: SignPath Integration Logic ===
    
    # 6.1. 查找生成的 MSIX 文件
    - name: Locate MSIX for Signing
      id: locate_msix
      shell: powershell
      run: |
        $sourceDir = "${{ github.workspace }}\AppPackages"
        # 找到生成的带 _Test 后缀的目录 (例如 XianYuLauncher_1.4.1.0_x64_Test)
        $testDir = Get-ChildItem -Path $sourceDir -Directory -Filter "*_Test" | Select-Object -First 1
        
        if (-not $testDir) {
            Write-Error "Could not find build output directory *_Test"
            exit 1
        }
        
        # 在里面找 .msix 文件
        $msixFile = Get-ChildItem -Path $testDir.FullName -Filter "*.msix" | Select-Object -First 1
        if (-not $msixFile) {
             # 如果没找到 msix, 可能是 appx
             $msixFile = Get-ChildItem -Path $testDir.FullName -Filter "*.appx" | Select-Object -First 1
        }
        
        if (-not $msixFile) {
            Write-Error "Could not find .msix or .appx file in $($testDir.FullName)"
            exit 1
        }

        Write-Host "Found artifact to sign: $($msixFile.FullName)"
        
        # 输出给后续步骤使用
        echo "MSIX_PATH=$($msixFile.FullName)" >> $env:GITHUB_ENV
        echo "MSIX_DIR=$($testDir.FullName)" >> $env:GITHUB_ENV

        # 准备输出目录
        $signedDir = "$env:GITHUB_WORKSPACE\SignedArtifacts"
        New-Item -ItemType Directory -Force -Path $signedDir | Out-Null
        echo "SIGNED_DIR=$signedDir" >> $env:GITHUB_ENV

    # 6.2. 提交给 SignPath 进行签名 (仅 Release 通道或非 Dev/Beta)
    # 暂时禁用 SignPath 签名，因为额度不足
    - name: Sign with SignPath
      if: false # ${{ !contains(github.ref, 'dev') && !contains(github.ref, 'beta') }}
      shell: pwsh
      env:
        SP_API_TOKEN: ${{ secrets.SIGNPATH_API_TOKEN }}
        SP_ORG_ID: '50751291-6d7b-4d37-bba2-bcd3fa936266'
        SP_PROJECT_SLUG: 'xianyulauncher'
        SP_POLICY_SLUG: 'release-signing'
        ARTIFACT_PATH: ${{ env.MSIX_PATH }}
        DOWNLOAD_DIR: ${{ env.SIGNED_DIR }}
      run: |
        $apiUrl = "https://app.signpath.io/API/v1/$env:SP_ORG_ID"
        
        Write-Host "Submitting signing request for $($env:ARTIFACT_PATH)..."
        
        # 使用 PowerShell 7 (pwsh) 的 -Form 自动处理 multipart/form-data
        $form = @{
            projectSlug = $env:SP_PROJECT_SLUG
            signingPolicySlug = $env:SP_POLICY_SLUG
            artifact = Get-Item -Path $env:ARTIFACT_PATH
        }
        
        try {
            $response = Invoke-RestMethod -Uri "$apiUrl/SigningRequests/SubmitWithArtifact" `
                -Method Post `
                -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" } `
                -Form $form
        } catch {
            Write-Error "Submission failed: $_"
            if ($_.Exception.Response) {
                $reader = New-Object System.IO.StreamReader $_.Exception.Response.GetResponseStream()
                Write-Error $reader.ReadToEnd()
            }
            exit 1
        }
            
        $requestId = $response.signingRequestId
        Write-Host "Signing Request ID: $requestId"
        
        # 轮询等待签名完成
        $status = "InProgress"
        while ($status -in "InProgress", "QueuedForProcessing", "Processing", "RetrievingArtifact", "Submitted") {
            # 缩短轮询间隔
            Start-Sleep -Seconds 3
            try {
                $check = Invoke-RestMethod -Uri "$apiUrl/SigningRequests/$requestId" `
                    -Method Get `
                    -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" }
                $status = $check.status
                Write-Host "Current Status: $status"
            } catch {
                Write-Warning "Status check returned error, retrying..."
            }
        }
        
        if ($status -ne "Completed") {
            Write-Error "Signing failed with final status: $status"
            exit 1
        }
        
        # 下载签名后的文件
        $signedArtifactLink = $check.signedArtifactLink
        $fileName = Split-Path $env:ARTIFACT_PATH -Leaf
        $outputFile = Join-Path $env:DOWNLOAD_DIR $fileName
        
        Write-Host "Downloading signed artifact to $outputFile..."
        
        Invoke-RestMethod -Uri $signedArtifactLink `
            -Method Get `
            -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" } `
            -OutFile $outputFile
            
        Write-Host "Signed artifact downloaded successfully."

    # 6.3. 用签名后的文件替换掉本地文件 (仅当使用了 SignPath 时)
    # 暂时禁用 SignPath 签名，因为额度不足
    - name: Replace with Signed Artifact
      if: false # ${{ !contains(github.ref, 'dev') && !contains(github.ref, 'beta') }}
      shell: powershell
      run: |
        $originalMsix = "${{ env.MSIX_PATH }}"
        $signedMsixDir = "${{ env.SIGNED_DIR }}"
        
        # SignPath 下载回来的文件名可能不一样，但目录里应该只有一个文件
        $signedFile = Get-ChildItem -Path $signedMsixDir -File | Select-Object -First 1
        
        if (-not $signedFile) {
            Write-Error "No signed file found in $signedMsixDir"
            exit 1
        }
        
        Write-Host "Replacing $originalMsix with $($signedFile.FullName)"
        
        # 覆盖原始文件
        Copy-Item -Path $signedFile.FullName -Destination $originalMsix -Force

    # 7. 重命名并打包 Zip (去除 _Test 后缀)
    - name: Rename and Zip
      shell: powershell
      run: |
        $sourceDir = "${{ github.workspace }}\AppPackages"
        $dirs = Get-ChildItem -Path $sourceDir -Directory -Filter "*_Test"
        
        foreach ($dir in $dirs) {
            # 新名称：去掉 _Test 后缀
            $newName = $dir.Name -replace "_Test$", ""
            $zipPath = Join-Path $sourceDir "$newName.zip"
            
            Write-Host "Zipping $($dir.FullName) to $zipPath"
            
            # 使用 Compress-Archive 打包目录内容
            Compress-Archive -Path "$($dir.FullName)\*" -DestinationPath $zipPath -Force
        }

    # 8. 上传 Artifact (Zip文件)
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Package-${{ matrix.platform }}
        path: ${{ github.workspace }}\AppPackages\*.zip

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download Artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: Display structure of downloaded files
      run: ls -R artifacts

    # 1. 生成更新日志 (AI Powered)
    - name: Install Python Dependencies
      run: pip install requests

    - name: Generate AI Changelog
      id: build_changelog
      shell: bash
      run: |
        # 设置默认值
        BASE_URL="${{ secrets.AI_API_BASE }}"
        if [ -z "$BASE_URL" ]; then BASE_URL="https://api.openai.com/v1"; fi
        
        MODEL="${{ secrets.AI_MODEL }}"
        if [ -z "$MODEL" ]; then MODEL="gpt-3.5-turbo"; fi
        
        # 如果没有配置 API Key，生成一个简单的占位符，防止流程失败
        if [ -z "${{ secrets.AI_API_KEY }}" ]; then
            echo "::warning::AI_API_KEY nor set. Skipping AI generation."
            echo "changelog=Auto-generated release (AI Token missing)." >> $GITHUB_OUTPUT
            exit 0
        fi

        echo "Generating changelog using model: $MODEL"
        
        python3 .github/scripts/generate_changelog_ai.py \
          --token "${{ secrets.AI_API_KEY }}" \
          --base-url "$BASE_URL" \
          --model "$MODEL" \
          --current-ref "${{ github.ref_name }}" \
          --output "CHANGELOG.md"
          
        # 读取文件内容到 Output (使用随机分界符防止冲突，并确保有换行)
        DELIMITER="EOF-$(date +%s)"
        echo "changelog<<$DELIMITER" >> $GITHUB_OUTPUT
        cat CHANGELOG.md >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "$DELIMITER" >> $GITHUB_OUTPUT

    # 2. 发布 Release (只上传标准带版本号的文件，保持干净)
    - name: Release
      uses: softprops/action-gh-release@v1
      with:
        body: ${{ steps.build_changelog.outputs.changelog }}
        files: artifacts/**/*.zip
        draft: false
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'dev') }}

