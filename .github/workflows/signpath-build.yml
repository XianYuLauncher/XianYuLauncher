name: SignPath Build and Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  build_and_sign:
    strategy:
      matrix:
        platform: [x86, x64, arm64]
    
    runs-on: windows-latest

    env:
      Solution_Name: XianYuLauncher.slnx
      Project_Path: XianYuLauncher/XianYuLauncher.csproj
      Configuration: Release
      Platform: ${{ matrix.platform }}
      Certificate_Path: GitHubActionsWorkflow.pfx

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    - name: Install .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 10.0.x

    - name: Restore secrets.json
      shell: powershell
      run: |
        $secretJson = '${{ secrets.APP_SECRETS_JSON }}'
        if ([string]::IsNullOrWhiteSpace($secretJson)) {
            Write-Warning "APP_SECRETS_JSON is possibly empty or not set."
        }
        New-Item -ItemType Directory -Force -Path XianYuLauncher | Out-Null
        $secretJson | Out-File -FilePath XianYuLauncher/secrets.json -Encoding utf8
        Write-Host "secrets.json restored."

    - name: Configure Channel
      shell: powershell
      run: |
        $refName = "${{ github.ref_name }}"
        $manifestPath = "XianYuLauncher/Package.appxmanifest"
        [xml]$xml = Get-Content $manifestPath
        
        $version = $refName
        if ($version.StartsWith("v")) { $version = $version.Substring(1) }
        
        if ($version -match '^(\d+\.\d+\.\d+)(.*)$') { 
            $baseVer = $matches[1]
            $suffix = $matches[2]
            $revision = 0
            if ($suffix -match '(\d+)$') {
                $revision = [int]$matches[1]
            }
            $cleanVer = "$baseVer.$revision"
            $xml.Package.Identity.Version = $cleanVer
            Write-Host "Set Package Version: $cleanVer"
        }

        if ($refName -match '-' -or -not ($refName -match '^v\d')) {
            Write-Host "Channel: DEV/BETA"
            $oldName = $xml.Package.Identity.Name
            $xml.Package.Identity.Name = "$oldName.Dev"
            Write-Host "Updated Identity Name: $oldName -> $($xml.Package.Identity.Name)"
            
            $xml.Package.Properties.DisplayName = "XianYu Launcher (Dev)"
            if ($xml.Package.Applications.Application.VisualElements) {
                $xml.Package.Applications.Application.VisualElements.DisplayName = "XianYu Launcher (Dev)"
            }
            
            $devAssetsPath = "XianYuLauncher/Assets/Dev"
            $targetAssetsPath = "XianYuLauncher/Assets"
            if (Test-Path $devAssetsPath) {
                Get-ChildItem -Path $devAssetsPath -File | ForEach-Object {
                    $dest = Join-Path $targetAssetsPath $_.Name
                    Copy-Item $_.FullName $dest -Force
                    Write-Host "Replaced Asset: $($_.Name)"
                }
            }
            
            echo "Build_Constants=DEV_CHANNEL" >> $env:GITHUB_ENV
        } else {
            Write-Host "Channel: STABLE"
            echo "Build_Constants=RELEASE_CHANNEL" >> $env:GITHUB_ENV
        }
        
        $xml.Save($manifestPath)

    - name: Restore NuGet
      run: nuget restore ${{ env.Solution_Name }}

    - name: Build (Produce MSIX)
      shell: powershell
      run: |
        msbuild ${{ env.Project_Path }} `
          /p:Configuration=${{ env.Configuration }} `
          /p:Platform=${{ env.Platform }} `
          /p:DefineConstants="${{ env.Build_Constants }}" `
          /p:GenerateAppxPackageOnBuild=true `
          /p:UapAppxPackageBuildMode=SideloadOnly `
          /p:AppxBundle=Never `
          /p:AppxPackageSigningEnabled=false `
          /p:AppxPackageDir="$env:GITHUB_WORKSPACE\AppPackages\" `
          /p:PackageOutputPath="$env:GITHUB_WORKSPACE\AppPackages\" `
          /p:GenerateAppInstallerFile=false

    # === NEW: SignPath Integration Logic ===
    
    # 1. 查找生成的 MSIX 文件
    - name: Locate MSIX for Signing
      id: locate_msix
      shell: powershell
      run: |
        $sourceDir = "${{ github.workspace }}\AppPackages"
        # 找到生成的带 _Test 后缀的目录 (例如 XianYuLauncher_1.4.1.0_x64_Test)
        $testDir = Get-ChildItem -Path $sourceDir -Directory -Filter "*_Test" | Select-Object -First 1
        
        if (-not $testDir) {
            Write-Error "Could not find build output directory *_Test"
            exit 1
        }
        
        # 在里面找 .msix 文件
        $msixFile = Get-ChildItem -Path $testDir.FullName -Filter "*.msix" | Select-Object -First 1
        if (-not $msixFile) {
             # 如果没找到 msix, 可能是 appx
             $msixFile = Get-ChildItem -Path $testDir.FullName -Filter "*.appx" | Select-Object -First 1
        }
        
        if (-not $msixFile) {
            Write-Error "Could not find .msix or .appx file in $($testDir.FullName)"
            exit 1
        }

        Write-Host "Found artifact to sign: $($msixFile.FullName)"
        
        # 输出给后续步骤使用
        echo "MSIX_PATH=$($msixFile.FullName)" >> $env:GITHUB_ENV
        echo "MSIX_DIR=$($testDir.FullName)" >> $env:GITHUB_ENV

        # 准备输出目录
        $signedDir = "$env:GITHUB_WORKSPACE\SignedArtifacts"
        New-Item -ItemType Directory -Force -Path $signedDir | Out-Null
        echo "SIGNED_DIR=$signedDir" >> $env:GITHUB_ENV

    # 3. 提交给 SignPath 进行签名 (使用 API 直接调用，绕过 Trusted Build System 限制)
    - name: Sign with SignPath (Direct API)
      shell: pwsh
      env:
        SP_API_TOKEN: ${{ secrets.SIGNPATH_API_TOKEN }}
        SP_ORG_ID: '50751291-6d7b-4d37-bba2-bcd3fa936266'
        SP_PROJECT_SLUG: 'xianyulauncher'
        SP_POLICY_SLUG: 'release-signing'
        ARTIFACT_PATH: ${{ env.MSIX_PATH }}
        DOWNLOAD_DIR: ${{ env.SIGNED_DIR }}
      run: |
        $apiUrl = "https://app.signpath.io/API/v1/$env:SP_ORG_ID"
        
        Write-Host "Submitting signing request for $($env:ARTIFACT_PATH)..."
        
        # 使用 PowerShell 7 (pwsh) 的 -Form 自动处理 multipart/form-data
        $form = @{
            projectSlug = $env:SP_PROJECT_SLUG
            signingPolicySlug = $env:SP_POLICY_SLUG
            artifact = Get-Item -Path $env:ARTIFACT_PATH
        }
        
        try {
            $response = Invoke-RestMethod -Uri "$apiUrl/SigningRequests/SubmitWithArtifact" `
                -Method Post `
                -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" } `
                -Form $form
        } catch {
            Write-Error "Submission failed: $_"
            if ($_.Exception.Response) {
                $reader = New-Object System.IO.StreamReader $_.Exception.Response.GetResponseStream()
                Write-Error $reader.ReadToEnd()
            }
            exit 1
        }
            
        $requestId = $response.signingRequestId
        Write-Host "Signing Request ID: $requestId"
        
        # 轮询等待签名完成
        $status = "InProgress"
        while ($status -in "InProgress", "QueuedForProcessing", "Processing", "RetrievingArtifact", "Submitted") {
            Start-Sleep -Seconds 5
            try {
                $check = Invoke-RestMethod -Uri "$apiUrl/SigningRequests/$requestId" `
                    -Method Get `
                    -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" }
                $status = $check.status
                Write-Host "Current Status: $status"
            } catch {
                Write-Warning "Status check returned error, retrying..."
            }
        }
        
        if ($status -ne "Completed") {
            Write-Error "Signing failed with final status: $status"
            exit 1
        }
        
        # 下载签名后的文件
        $signedArtifactLink = $check.signedArtifactLink
        $fileName = Split-Path $env:ARTIFACT_PATH -Leaf
        $outputFile = Join-Path $env:DOWNLOAD_DIR $fileName
        
        Write-Host "Downloading signed artifact to $outputFile..."
        
        Invoke-RestMethod -Uri $signedArtifactLink `
            -Method Get `
            -Headers @{ Authorization = "Bearer $env:SP_API_TOKEN" } `
            -OutFile $outputFile
            
        Write-Host "Signed artifact downloaded successfully."

    # 3. 用签名后的文件替换掉本地文件，以便后续打包 Zip
    - name: Replace with Signed Artifact
      shell: powershell
      run: |
        $originalMsix = "${{ env.MSIX_PATH }}"
        $signedMsixDir = "${{ env.SIGNED_DIR }}"
        
        # SignPath 下载回来的文件名可能不一样，但目录里应该只有一个文件
        $signedFile = Get-ChildItem -Path $signedMsixDir -File | Select-Object -First 1
        
        if (-not $signedFile) {
            Write-Error "No signed file found in $signedMsixDir"
            exit 1
        }
        
        Write-Host "Replacing $originalMsix with $($signedFile.FullName)"
        
        # 覆盖原始文件
        Copy-Item -Path $signedFile.FullName -Destination $originalMsix -Force
        
        # 顺便把 SignPath 签名时生成的 .p7x 签名文件更新一下？ MSIX 内部签名更新了即可。
        # MSIX 不需要外部 .p7x，签名数据嵌入在包内。

    # === End SignPath Integration ===

    # 7. 重命名并打包 Zip (现在打包进去的是已签名的 MSIX)
    - name: Rename and Zip
      shell: powershell
      run: |
        $sourceDir = "${{ github.workspace }}\AppPackages"
        $dirs = Get-ChildItem -Path $sourceDir -Directory -Filter "*_Test"
        
        foreach ($dir in $dirs) {
            # 新名称：去掉 _Test 后缀
            $newName = $dir.Name -replace "_Test$", ""
            $zipPath = Join-Path $sourceDir "$newName.zip"
            
            Write-Host "Zipping $($dir.FullName) to $zipPath"
            
            Compress-Archive -Path "$($dir.FullName)\*" -DestinationPath $zipPath -Force
        }

    # 8. 上传 Artifact (Zip文件)
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Package-${{ matrix.platform }}
        path: ${{ github.workspace }}\AppPackages\*.zip

  release:
    needs: build_and_sign
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Download Artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: Display structure of downloaded files
      run: ls -R artifacts

    - name: Build Changelog
      id: build_changelog
      uses: mikepenz/release-changelog-builder-action@v4
      with:
        configuration: ".github/changelog-configuration.json"
        ignorePreReleases: ${{ !contains(github.ref, 'beta') && !contains(github.ref, 'dev') }}

    - name: Release
      uses: softprops/action-gh-release@v1
      with:
        body: ${{ steps.build_changelog.outputs.changelog }}
        files: artifacts/**/*.zip
        draft: false
        prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'dev') }}
